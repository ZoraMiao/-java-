# 垃圾收集(GC)
## 1、判断对象是否存活
### 1.1引用计数算法
  给对象添加一个引用计数器，每当有一个地方引用他时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用，将对其回收。<br>
  但是主流的java虚拟机里面没有选用这种方法来管理内存，主要因为它很难解决对象之间相互循环引用的问题。例如：<br>
  ```java
  public class MyObject {
    public Object ref = null;
    public static void main(String[] args) {
        MyObject myObject1 = new MyObject();
        MyObject myObject2 = new MyObject();
        myObject1.ref = myObject2;
        myObject2.ref = myObject1;
        myObject1 = null;
        myObject2 = null;
    }
  }
  ```
  这两个对象没有任何其他的引用，但是他们之间相互引用着对方，导致它们的计数器都不为0，于是引用计数法无法通知GC收集器回收它们。<br>
### 1.2可达性分析算法
  通过一系列的称为"GC Roots"的对象作为起点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用；是可回收对象。<br>
  在java语言中，可作为GC Roots的对象包括下面几种：<br>
  * 虚拟机栈（栈帧中的本地变量表）中引用的对象
  * 方法区中类静态属性引用的对象
  * 方法区中常量引用的对象
  * 本地方法栈中JNI（即一般说的Native方法）引用的对象
## 2、垃圾回收算法
### 2.1标记-清除算法（Mark-Sweep）
  标记清除法是现代垃圾回收算法的思想基础。<br>
  标记清除法将垃圾回收分为两个阶段：**标记阶段**和**清除阶段**。<br>
  在标记阶段，使用**可达性分析算法**，首先通过根节点，标记所有从根节点开始的可达对象，因此未被标记的对象就是未被引用的垃圾对象。然后在清除阶段，清除所有未被标记的对象。这种方法可以解决循环引用的问题，只有两个对象不可达，即使它们互相引用也无济于事。也是会被判定位不可达对象。<br>
  标记清除算法可能产生的最大的问题就是**空间碎片**。空间碎片太多会导致当程序需要为较大对象分配内存时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。<br>
  如下图所示，简单描述了使用标记清除法对一块连续的内存空间进行回收。<br>
![](https://images2015.cnblogs.com/blog/989246/201704/989246-20170406161514082-1220415753.jpg)<br>
  从上图可以看出，回收后的内存空间不再连续。在对象的对空间分配过程中，尤其是大对象的内存分配，不连续内存空间的工作效率要低于连续空间的，这也是该算法的缺点。**注意：标记清除算法先通过根节点标记所有可达对象，然后清除所有不可达对象，完成垃圾回收。后面会讲到标记压缩算法，注意两者的区别。**
### 2.2复制算法
  算法思想：将原有的内存空间分为两块相同的存储空间，每次只使用一块，在垃圾回收时，将正在使用的内存块中存活对象复制到未使用的那一块内存空间中，之后清除正在使用的内存块中的所有对象，完成垃圾回收。<br>
  如果系统中的垃圾对象很多，复制算法需要复制的存活对象就会相对较少 **（适用场景）** 。因此，在真正需要垃圾回收的时刻，复制算法的效率是很高的。而且，由于存活对象在垃圾回收过程中是一起被赋值到另一块内存空间中的，因此，可确保回收的内存空间是没有碎片的。 **（优点）**<br>
  但是复制算法的代价是将系统内存空间折半，只使用一半空间，而且如果内存空间中垃圾对象少的话，复制对象也是很耗时的，因此，单纯的复制算法也是不可取的。 **（缺点）**<br>
  ![](https://images2015.cnblogs.com/blog/989246/201704/989246-20170406162053957-592638524.jpg)
### 2.3标记-整理算法（Mark-Compact）
  复制算法的高效性是建立在存活对象少、垃圾对象多的情况下，这种情况在新生代比较常见，但是在老年代中，大部分对象都是存活的对象，如果还是有复制算法的话，成本会比较高。因此，基于老年代这种特性，应该使用其他的回收算法。<br>
  标记压缩算法是老年代的回收算法，它在标记清除算法的基础上做了优化。（回忆一下，标记清除算法的缺点，垃圾回收后内存空间不再连续，影响了内存空间的使用效率。。。）,和标记清除算法一样，标记压缩算法也首先从根节点开始，对所有可达的对象做一次标记，但之后，它并不是简单的清理未标记的对象，而是将所有的存活对象压缩到内存空间的一端，之后，清理边界外所有的空间。这样做**避免了碎片的产生**，又不需要两块相同的内存空间，因此性价比高。
通过根节点标记出所有的可达对象后，进行对象的移动，将所有的可达对象移到一端，并保持他们之间的引用关系，最后，清理边界外的空间。<br>
![](https://images2015.cnblogs.com/blog/989246/201704/989246-20170406162848519-1635773526.jpg)
### 2.4分代收集算法
  当前商业虚拟机的垃圾收集都采用“分代收集”(Generational Collection)算法，这种算法并没有什么新的思想，只是根据对象存活周期的不同将内存划分为几块。一般是把 Java堆分为**新生代**和**老年代**，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记一-清理”或者“标记一整理”算法来进行回收。<br>
### 相关文章
[垃圾收集算法](https://blog.csdn.net/wen7280/article/details/54428387)
## 3、典型的垃圾回收算法
  垃圾收集算法是垃圾收集器的理论基础，而垃圾收集器就是其具体实现。下面介绍HotSpot虚拟机提供的几种垃圾收集器。**如果两个收集器之间存在连线，就说明他们可以搭配使用**<br>
  ![](https://images2018.cnblogs.com/blog/491706/201803/491706-20180306153700783-1725793368.png)
### 3.1. Serial/Serial Old
  最古老的收集器，是一个单线程收集器，用它进行垃圾回收时，必须暂停所有用户线程。Serial是针对新生代的收集器，采用Copying算法；而Serial Old是针对老年代的收集器，采用Mark-Compact算法。优点是简单高效，缺点是需要暂停用户线程。
### 3.2. ParNew
  Seral/Serial Old的多线程版本，使用多个线程进行垃圾收集。
### 3.3. Parallel Scavenge
  新生代的并行收集器，回收期间不需要暂停其他线程，采用Copying算法。该收集器与前两个收集器不同，主要为了达到一个可控的吞吐量。
### 3.4. Parallel Old
  Parallel Scavenge的老年代版本，采用Mark-Compact算法和多线程。
### 3.5. CMS
  Current Mark Sweep收集器是一种以最小回收时间停顿为目标的并发回收器，因而采用Mark-Sweep算法。
### 3.6. G1
  G1(Garbage First)收集器技术的前沿成果，是面向服务端的收集器，能充分利用CPU和多核环境。是一款并行与并发收集器，它能够建立可预测的停顿时间模型。
### 相关文章
  [垃圾收集器](https://blog.csdn.net/tjiyu/article/details/53983650)
## 4、垃圾收集相关参数
![](https://github.com/ZoraMiao/java/blob/master/垃圾收集相关参数.png)
## 5、内存分配与回收策略
   对象的内存分配，往大方向上讲，多数是在堆上分配，其中对象主要分配在Eden区，如果启动TLAB，将按照线程优先在TLAB上分配，但也有少数情况下会分配在老年区。<br>
### 5.1、对象优先在Eden分配
  首先介绍两种GC:<br>
    ①新生代GC，也叫Minor GC，指发生在新生代的垃圾回收动作，由于JAVA的大多数对象具有朝生夕灭的特性，因此这种GC发生的很频繁，回收速度也较快。<br>
    ②老年代GC，也叫Full GC或者Major GC，指发生在老年代的垃圾收集动作，经常伴随至少一次的Minor GC，但也不是绝对的，速度一般比Minor GC慢10倍以上。<br>
  当Eden区没有足够的空间分配时，虚拟机会发起一次Minor GC，这里我们要知道的是新生区包括Eden区和一个Survivor区，但是是存在2个Survivor区的，2个Suivivor中必定有一个区是空的。因此新生代总的可用空间就是（Eden+1个Survivor）。如果分配时发现Eden区没有足够的内存，那么会发生一次Minor GC，这期间发生的动作会导致Eden区的对象进入一个Survivor区，如果虚拟机发现Eden区的对象太大以至于无法全部放入1个Survivor区，会通过分配担保机制提前将Eden区内的对象转移到老年代去。
### 5.2、大对象直接进入老年代
  因为新生代采用复制算法收集内存，因此大对象对于JVM是很苦恼的，尤其是当这些大对象很短命的时候，经常出现大对象容易导致内存还有不少空间时就提前出发垃圾收集以获取足够的连续空间来安置他们。因此，当产生大对象时，会将其直接分配在老年代。
### 5.3、长期存活的对象将进入老年代
  虚拟机管理内存的思想是分代收集。每个对象定义了一个对象年龄计数器，当对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor中，并且其年龄被置为1，每度过一次GC（即每次从一个Survivor转移到另一个Survivor中），年龄增加1，当到达15岁时，晋升到老年代。15这个年龄值是可以人为改变的。但是并不是一定要到达年龄阀值时对象才会被转移到老年代，JVM中存在动态对象年龄判定来适应不同程序的内存状况。如果在Survivor空间中相同年龄的所有对象的大小总和大于Survivor空间的一半，这些对象可以提前直接进入老年代。
### 5.4、空间分配担保
  在发生Minor GC之前，JVM会先检查老年代最大可用的连续空间是否大于新生代所有对象的总空间（防止在经过这次Minor GC之后存活的新生代的所有对象年龄达到阀值或者满足动态对象年龄判定条件，导致进入老年代时，老年代空间不够），如果这个条件成立，那么Minor GC可以确保是安全的。如果不成立，会继续检查老年代最大可用连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，尝试进行一次Minor GC，尽管这次Minor GC是有风险的；如果小于，那么不允许冒险，此时就需要进行一次Full GC来清理老年代。<br>
  上文提到的冒险：新生代采用复制收集算法，但是为了内存利用率，只是用一个Survivor作为轮换备份，Minor GC后最极端的情况是新生代的所有对象都存活，这时Eden区的对象要进入Survivor区中，老年代要进行分配担保来把Survivor无法容纳的对象直接进入老年代。因为经过Minor GC后到底有多少对象存活在完成内存回收之前是未知的，因此取之前每次晋升到老年代对象的容量的平均大小作为经验值与老年代剩余空间进行比较来决定是否进行Full GC来让老年代腾出更多空间。
### 相关文章
  [JVM之内存分配与回收策略](https://www.cnblogs.com/xiaoxi/p/6557473.html)
