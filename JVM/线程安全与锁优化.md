## 线程安全
> 当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象是线程安全的。
* java语言中各种操作共享的数据分为以下5类：**不可变、绝对线程安全、相对线程安全、线程兼容和线程对立。**
  * **不可变：** 不可变（Immutable）的对象一定是线程安全的，无论是对象的方法实现还是方法的调用者，都不需要再采取任何的线程安全保障措施。（例如final，只要一个不可变的对象被正确地构建出来（没有发生this引用逃逸的情况），那其外部的可见壮、状态永远也不会改变，永远也不会看到它在多个线程之中处于不一致的装态。）
 > java语言中，如果共享数据是一个基本数据类型，那么只要在定义时使用final关键字修饰它就可以保证它是不可变的。如果共享数据是一个对象，那就需要保证对象的行为对其状态产生任何影响才行。例如java.lang.String类的对象，它是一个典型的不可变对象，我们调用它的substring()、replace()和concat()这些方法都不会影响它原来的值，只会返回一个新构造的字符串对象。
  * **绝对线程安全：**一个类要达到“不管运行时环境如何，调用者都不需要任何额外的同步措施”。在java API中标注自己是线程安全的类，大多数都不是绝对的线程安全。例如java.lang.Vector是一个线程安全的容器，因为它的add()、get()和size()这类方法都是被synchronized修饰的，尽管这样效率很低，但确实是安全的。但是，即使它所有的方法都被修饰成同步的，也不意味着调用它的时候永远不再需要同步手段。
  * **相对线程安全：** 就是我们通常意义上所讲的线程安全，它需要保证对这个对象单独的操作时线程安全的，我们在调用的时候不需要做额外的保障措施。但是对于一些特定顺序的连续调用，就可能需要在调用端使用额外的同步手段来保证调用的正确性。像java.lang.Vector就是相对线程安全的。
  * **线程兼容：** 是指队形本身并不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全地使用。java API中大部分的类都是属于线程兼容的，如与前面的Vector和HashTable相对应的集合类ArrayList和HashMap等。
  * **线程对立：** 是指无论调用端是否采取了同步措施，都无法在多线程环境中并发使用的代码。由于java语言天生就具备多线程特性，线程对立排斥多线程的代码是很少出现的，而且通常都是有害的，应当尽量避免。例如Thread类的suspend()和resume()方法，如果两个线程同时持有一个线程对象，一个尝试去中断线程，另一个尝试去恢复线程，如果并发进行的话，无论调用时是否进行了同步，目标线程都是存在死锁风险的。
## 线程安全的实现方法
  * **1、互斥同步（悲观）**
    * 是指在多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一个（或一些，使用信号量的时候）线程使用。**临界区**、**互斥量**、**信号量** 都是主要的互斥实现方式。
    * 在java中，最基本的互斥手段就是synchronized关键字，synchronized关键字经过编译之后，会在同步块的前后分别形成monitorenter和monitorexit这两个字节码指令，这两个字节码都需要一个reference类型的参数来指明要锁定和解锁的对象。如果Java程序中的synchronized明确指定了对象参数，那就是这个对象的reference;如果没有明确指定，那就根据synchronized修饰的是实例方法还是类方法，去取对应的对象实例或Class对象来作为锁对象。
    * 根据虚拟机规范的要求，在执行monitorenter指令时，首先要尝试获取对象的锁。如果这个对象没被锁定，或者当前线程已经拥有了那个对象的锁，把锁的计数器加1，相应的，在执行monitorexit指令时会将锁计数器减1,当计数器为0时，锁就被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到对象锁被另外一个线程释放为止。
    * 在虚拟机规范对monitorenter和monitorexit的行为描述中，有两点是需要特别注意的。首先，synchronized同步块对同一条线程来说是可重人的，不会出现自己把自己锁死的问题。其次，同步块在已进人的线程执行完之前，会阻塞后面其他线程的进人。Java的线程是映射到操作系统的原生线程之上的，如果要阻塞或唤醒一个线程，都需要操作系统来帮忙完成，这就需要从用户态转换到核心态中，因此状态转换需要耗费很多的处理器时间。对于代码简单的同步块(如被synchronized修饰的getter() 或setter()方法)，状态转换消耗的时间有可能比用户代码执行的时间还要长。所以synchronized是Java语言中一个重量级(Heavyweight)的操作，有经验的程序员都会在确实必要的情况下才使用这种操作。而虚拟机本身也会进行一些优化，譬如在通知操作系统阻塞线程之前加入一段自旋等待过程，避免频繁地切人到核心态之中。
    * 除了synchronized之外，我们还可以使用java.util.concurrent(下文称J.U.C)包中的重人锁(ReentrantLock)来实现同步，在基本用法t. ReentrantLock与synchronized很相似，他们都具备一样的线程重入特性，只是代码写法上有点区别，一个表现为API层面的互斥锁(lock()和unlock()方法配合try /finalliy，语句块来完成)，另一个表现为原生语法层面的互斥锁。不过，相比synchronized,ReentrantLock增加了一些高级功能， 主要有以下3项。**等待可中断、可实现公平锁，以及锁可以绑定多个条件**。
> * **等待可中断** 是指当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情，可中断特性对处理执行时间非常长的同步块很有帮助。
>  * **公平锁** 是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁;而非公平锁则不保证这一点，在锁被释放时，任何一个等待锁的线程都有机会获得锁。synchronized中的锁是非公平的，ReentrantLock 默认情况下也是非公平的，但可以通过带布尔值的构造函数要求使用公平锁。
>  * **锁绑定多个条件** 是指个ReentrantIock对象可以同时绑定多个Condition对象，而在synchronized中，锁对象的wait(和notify()或notifyAll()方法可以实现一个隐含的条件，如果要和多于一个的条件关联的时候，就不得不额外地添加一个锁，而ReentrantLock则无须这样做，只需要多次调用newCondition()方法即可。
  * **2、非阻塞同步（乐观）**
    * 基于冲突检测的乐观并发策略，通俗的说，就是先进行操作，如果没有其他线程争用共享数据，那操作就成功了；如果共享数据有争用，产生了冲突，那就再采取其他的补偿措施，该策略不需要讲线程挂起。
    * 靠硬件来完成，保证一个从语义上看起来需要多次操作的行为只通过一条处理器指令就能完成，这类指令常用的有：
      * 测试并设置（Test-and-Set）
      * 获取并增加（Fetch-and Increment）
      * 交换（Swap）
      * 比较并交换（Compare-and-Swap）
      * 加载链接/条件存储（Load-Linked/Store-Conditional）
  * **3、无同步方案**
    * 要保证线程安全，并不是一定就要进行同步， 两者没有因果关系。同步只是保证共享数据争用时的正确性的手段，如果一个方法 本来就不涉及共享数据，那它自然就无须任何同步措施去保证正确性，因此会有一些代码天生就是线程安全的，简单介绍一下两种：
    * **可重入代码( Reentrant Code)** :这种代码也叫做纯代码(Pure Code),可以在代码执行的任何时刻中断它，转而去执行另外一段代码(包括递归调用它本身)，而在控制权返回后，原来的程序不会出现任何错误。相对线程安全来说，可重入性是更基本的特性，它可以保证线程安全，即所有的可重人的代码都是线程安全的，但是并非所有的线程安全的代码都是可重入的。
    * 可重人代码有一些共同的特征， 例如不依赖存储在堆上的数据和公用的系统资源、用到的状态量都由参数中传人、不调用非可重入的方法等。我们可以通过一个简单的原则来判断代码是否具备可重入性:如果一个方法，它的返回结果是可以预测的，只要输人了相同的数据，就都能返回相同的结果，那它就满足可重入性的要求，当然也就是线程安全的。
    * **线程本地存储(Thread Local Storage)** :如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行?如果能保证，我们就可以把共享数据的可见范围限制在同一个线程之内，这样，无须同步也能保证线程之间不出现数据争用的问题。
## 锁优化
* 技术包括**适应性自旋、锁消除、锁粗化、轻量级锁和偏向锁**
