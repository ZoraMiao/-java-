## 关键对象加载时机
* MyBatis根据对关联对象查询的select语句的执行时机，分为三种类型：**直接加载**、**侵入式延迟加载**与**深度延迟加载**
  *  **直接加载:** 执行完对主加载对象的select语句，马上执行对关联对象的select查询。
  *  **侵入式加载：** 执行对主加载对象的查询时，不会执行对关联对象的查询。但当要访问主加载对象的详情时，就会马上执行关联对象的select查询。即对关联对象的查询执行，侵入到了主加载对象的详情访问中。也可以这样理解：将关联对象的详情侵入到了主加载对象的详情中，即将关联对象的详情作为主加载对象的详情的一部分出现了。
  *  **深度延迟：** 执行对主加载对象的查询时，不会执行对关联对象的查询。访问主加载对象的详情时也不会执行关联对象的select查询。只有当真正访问关联对象的详情时，才会执行对关联对象的select查询。<br>
**注意：延迟加载的应用要求，关联对象的查询与主加载对象的查询必须是分别进行的select语句，不能是使用对表连接所进行的select查询。** 因为，多表连接查询，其实质是对一张表的查询，对由多个表连接后形成的一张表的查询。会一次性将多张表的所有信息查询出来。
## 查询缓存
* mybatis的查询缓存机制，根据缓存区的作用域与生命周期，可划分为两种：**一级缓存**与**二级缓存**。
* mybatis查询缓存的作用域是根据映射文件mapper的**namespace**划分的，相同namespace的mapper查询数据存放在同一个缓存区域。不同namespace下的数据互不干扰。无论是一级缓存还是二级缓存，都是按照namespace进行分别存放的。
* 但一、二级缓存的不同之处在于，Sqlsession一旦关闭，则Sqlsession中的数据将不存在，即一级缓存就不覆存在。而二级缓存的生命周期会与整个应用同步，与Sqlsession是否关闭无关。换句话说，一级缓存是在同一线程（同一Sqlsession）间共享数据，而二级缓存是在不同线程（不同Sqlsession）间共享数据。
### 一级缓存
* mybatis的一级缓存是基于org.apache.ibatis.cache.impl.PerpetualCache类的HashMap本地缓存，其作用域是Sqlsession。在同一个Sqlsession中两次执行相同的sql查询语句，第一次执行完毕后，会将查询结果写入缓存中，第二次会从缓存中直接获取数据，而不再到数据库中进行查询，从而提高查询效率。
* 当一个Sqlsession结束后，该Sqlsession中的一级缓存也就不存在了。**mybatis默认一级缓存是开启状态，且不能关闭。**
