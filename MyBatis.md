## 关键对象加载时机
* MyBatis根据对关联对象查询的select语句的执行时机，分为三种类型：**直接加载**、**侵入式延迟加载**与**深度延迟加载**
  *  **直接加载:** 执行完对主加载对象的select语句，马上执行对关联对象的select查询。
  *  **侵入式加载：** 执行对主加载对象的查询时，不会执行对关联对象的查询。但当要访问主加载对象的详情时，就会马上执行关联对象的select查询。即对关联对象的查询执行，侵入到了主加载对象的详情访问中。也可以这样理解：将关联对象的详情侵入到了主加载对象的详情中，即将关联对象的详情作为主加载对象的详情的一部分出现了。
  *  **深度延迟：** 执行对主加载对象的查询时，不会执行对关联对象的查询。访问主加载对象的详情时也不会执行关联对象的select查询。只有当真正访问关联对象的详情时，才会执行对关联对象的select查询。<br>
**注意：延迟加载的应用要求，关联对象的查询与主加载对象的查询必须是分别进行的select语句，不能是使用对表连接所进行的select查询。** 因为，多表连接查询，其实质是对一张表的查询，对由多个表连接后形成的一张表的查询。会一次性将多张表的所有信息查询出来。
## 查询缓存
* mybatis的查询缓存机制，根据缓存区的作用域与生命周期，可划分为两种：**一级缓存**与**二级缓存**。
* mybatis查询缓存的作用域是根据映射文件mapper的**namespace**划分的，相同namespace的mapper查询数据存放在同一个缓存区域。不同namespace下的数据互不干扰。无论是一级缓存还是二级缓存，都是按照namespace进行分别存放的。
* 但一、二级缓存的不同之处在于，Sqlsession一旦关闭，则Sqlsession中的数据将不存在，即一级缓存就不覆存在。而二级缓存的生命周期会与整个应用同步，与Sqlsession是否关闭无关。换句话说，一级缓存是在同一线程（同一Sqlsession）间共享数据，而二级缓存是在不同线程（不同Sqlsession）间共享数据。
### 一级缓存
* mybatis的一级缓存是基于org.apache.ibatis.cache.impl.PerpetualCache类的HashMap本地缓存，其作用域是Sqlsession。在同一个Sqlsession中两次执行相同的sql查询语句，第一次执行完毕后，会将查询结果写入缓存中，第二次会从缓存中直接获取数据，而不再到数据库中进行查询，从而提高查询效率。
* 当一个Sqlsession结束后，该Sqlsession中的一级缓存也就不存在了。**mybatis默认一级缓存是开启状态，且不能关闭。**
 * 缓存的底层实现是一个Map,Map的value是查询结果、Map的key，即查询依据，使用ORM架构不同，查询依据是不同的。mybatis的查询依据是sql的id+SQL语句；hibernate的查询依据是，查询结果对象的id。
 * 增删改操作都会清空一级缓存
### 二级缓存
#### 内置二级缓存
* 由于mybatis从缓存中读取数据的依据与SQL的id相关，而非查询出的对象。所以，**使用二级缓存的目的，不是在多个查询间共享查询结果**（所有查询中只要查询结果中存在该对象，就直接从缓存中读取，这是对查询结果的共享，Hibernate中的缓存就是为了在多个查询间共享查询结果，但mybatis的不是），**而是为了防止同一查询（相同的Sql id、相同的Sql语句）的反复执行**
* 开启内置的二级缓存步骤：
 *  1）对实体进行序列化（即实体类要实现Serializable）
 *  2）在映射文件中添加<cache/>标签
**注意：**<br>
> 1、增删改同样也会清空二级缓存  
  2、对于二级缓存的清空，实质上是对所查找key对应的value置为null，而并非将<key,value>对，即Entry对象删除   
  3、从DB中进行select查询的条件是：
  > * 1）缓存中根本就不存在这个key所对应的Entry对象 
   * 2）缓存中存在该key所对应的Entry对象，但其value为null
#### ehcache二级缓存
