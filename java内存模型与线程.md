## 1、内存间交互的操作
* 关于主内存与工作内存之间具体的交互协议，即一个变量如何从主内存拷贝到工作内存，如何从工作内存同步回主内存之类的实现细节，Java内存模型中定义了以下8种操作来完成，虚拟机实现时必须保证下面提及的每一种操作都是原子的、不可再分的(对于double和类型的变量来说，load、store、read和write 操作在某些平台上允许有例外).
  * lock (锁定):作用于**主内存** 的变量，它把一个变量标识为一条线程独占的状态。
  * unlock (解锁):作用于**主内存** 的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。
  * read (读取):作用于**主内存** 的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用。
  * load (载人):作用于**工作内存** 的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。
  * use (使用):作用于**工作内存** 的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作。
  * assign (赋值):作用于**工作内存** 的变量，它把一个从执行引擎接收到的值赋给工作内存的交量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。
  * store (存储):作用于**工作内存** 的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的write操作使用。
  * write (写入)：作用于**主内存** 的变量，它把store操作从工作内存中的到的变量的值放入主内存的变量中。<br>
* 如果要把一个变量从主内存复制到工作内存，那就要顺序地执行read和load操作，如果要把变量从工作内存同步回主内存，就要顺序地执行store和write操作。注意，Java 内存模型只要求上述两个操作必须按顺序执行，而没有保证是连续执行。也就是说，read 与load之间、store 与write之间是可插入其他指令的，如对主内存中的变量a、b进行访问时，一种可能出现顺序是read a、read b、 load b、 load a. 除此之外，Java内存模型还规定了在执行上述8种基本操作时必须满足如下规则:
  * 不允许read和load、store 和write操作之一单独出现， 即不允许一个变量从主内存读取了但工作内存不接受，或者从工作内存发起回写了但主内存不接受的情况出现。
  * 不允许一个线程丢弃它的最近的assign 操作，即变量在工作内存中改变了之后必须把该变化同步回主内存。
  * 不允许一个线程无原因地(没有发生过任何assign操作)把数据从线程的工作内存同步回主内存中。
  * 一个新的变量只能在主内存中“诞生”，不允许在工作内存中直接使用一个未被初始化(load或assign) 的变量，换句话说，就是对一个变量实施use、 store操作之前，必须先执行过了assign 和load操作。
  * 一个变量在同一个时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。
  * 如果对一个变量执行lock操作，那将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或asisn操作初始化变量的值。
  * 如果一个变量事先没有被lock操作锁定，那就不允许对它执行unlock操作，也不允许去unlock一个被其他线程锁定住的变量。
  * 对个变量执行unlock操作之前，必须先把此变量同步回主内存中(执行store、write操作)。
## 2、对于volatile型变量的特殊规则
* 关键字volatile可以说是java虚拟机提供的最轻量级的同步机制。
* 当一个变量定义为volatile之后，它将具备两种特性，第一是**保证此变量对所有线程的可见性**，这里的“可见性”是指当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。而普通变量不能做到这一点，普通变量的值在线程间传递均需要通过主内存来完成，例如，线程A修改一个普通变量的值，然后向主内存进行回写，另外一条线程B在线程A回写完成了之后再从主内存进行读取操作，新变量值才会对线程B可见。
* 关于volatile 变量的可见性，经常会被开发人员误解，认为以下描述成立:“ volatile变量对所有线程是立即可见的，对volatile变量所有的写操作都能立刻反应到其他线程之中，换句话说，volatile 变量在各个线程中是致的，所以基 于volatile 变量的运算在并发下是安全的”。这句话的论据部分并没有错，但是其论据并不能得出“基于volatile变量的运算在并发下是安全的”这个结论。volatile 变量在各个线程的工作内存中不存在一致性问题 (在各个线程的工作内存中，volatile 变量也可以存在不一致的情况，但由于每次使用之前都要先刷新，执行引擎看不到不一致的情况，因此可以认为不存在一 致性问题)， 但是Java里面的运算并非原子操作，导致vlatile变量的运算在并发下一样是不安全的。
* 第二，**禁止指令重排序优化**普通的变量仅仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而不能保证变量赋值操作的顺序与程序代码中的执行顺序一致。
## 原子性、可见性和有序性
* **原子性：** 由java内存模型来直接保证的原子性变量操作包括read、load、assign、use、store和write，大致可以认为基本数据类型的访问读写是具备原子性的（除了double、long）。
* **可见性：** 是指当一个线程修改了共享变量的值，其他线程能够立即得知这个修改。Java 内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方式来实现可见性的，无论是普通变量还是volaile变量都是如此，普通变量与volatile变量的区别是，volatile 的特殊规则保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新。因此，可以说**volatile保证了多线程操作时变量的可见性，而普通变量则不能保证这一点。**
* 除了volatile之外，Java还有两个关键字能实现可见性，即synchronized和final。同步块的可见性是由“对一个变量执行unlock操作之前，必须先把此变量同步回主内存中(执行store、write 操作)”这条规则获得的，而final 关键字的可见性是指:被final修饰的字段在构造器中一旦初始化完成，并且构造器没有把“this”的引用传递出去(this 引用逃逸是一一件很危险的事情，其他线程有可能通过这个引用访问到“初始化了一半”的对象)，那在其他线程中就能看见final字段的值。
* **有序性(Ordering)**:Java程序中天然的有序性可以总结为一句话:**如果在本线程内观察，所有的操作都是有序的;如果在一个线程中观察另一个线程，所有的操作都是无序的**。前半句是指“线程内表现为串行的语义”( Within-Thread As-If-Serial Semantics),后半句是指“指令重排序”现象和“工作内存与主内存同步延迟”现象。
* Java语言提供了volatile和synchronized两个关键字来保证线程之间操作的有序性，volatile关键字本身就包含了禁止指令重排序的语义，而synchronized则是由“一个变量在同一个时刻只允许一条线程对其进行lock操作”这条规则获得的，这条规则决定了持有同一个锁的两个同步块只能串行地进入。
## 先行发生原则
* **程序次序原则：** 在一个线程内，按照程序代码顺序，书写在前面的操作先行发生与书写在后面的操作。准确地说，应该是控制流顺序而不是程序代码顺序，因为要考虑分支、循环等结构。
* **管程锁定规则：** 一个unlock操作先行发生与后面对同一锁的lock操作。**这里必须强调是同一个锁**，而“后面”是指时间上的先后顺序。
* **volatile变量规则：** 对一个volatile变量的写操作先行发生于后面对这个变量的读操作。这里的“后面”是指时间上的先后顺序。
* **线程启动规则：** Thread对象的start()方法先行发生于此线程的每一个动作。
* **线程终止规则：** 线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值等手段检测到线程已经终止执行。
* **线程中断规则：** 对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测到是否有中断发生。
* **对象终结规则：** 一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize()方法的开始。
* **传递性：** 如果操作A先行发生于操作B，操作B先行发生于操作C，则可得出操作A先行发生于操作C。
## java与线程
* java语言定义了5种线程状态，在任意一个时间点，一个线程有且只有其中的一种状态，5种状态如下：
  * **新建（New）：** 创建后尚未启动的线程处于这种装态。
  * **运行（Runable）：** Runable包括了操作系统线程状态中的Runing和Ready，也就是处于此状态的线程有可能正在被执行，也有可能正在等待CPU为它分配执行时间。
  * **无限期等待（Waiting）：** 处于这种装态的线程不会被分配CPU执行时间，它们要等待被其他线程显示唤醒。以下方法会让线程陷入无限期的等待时间：
    * 没有设置Timeout参数的Object.wait()方法;
    * 没有设置Timeout参数的Thread.join()方法；
    * LockSupport.park()方法。
  * **限期等待（Time Waiting）:** 处于这种装态的线程也不会被分配CPU执行时间，不过无须等到被其他线程显示唤醒，在一定时间之后它们会由系统自动唤醒。以下方法会让线程进入限期等待装态：
    * Thread.sleep()方法;
    * 设置了Timeout参数的Object.wait()方法；
    * 设置了Timeout参数的Thread.join()方法；
    * LockSupport.parkNanos()方法；
    * LockSupport。parkUntil()方法。
  * **阻塞（Blocked）：** 线程被阻塞了，“阻塞装态”与“等待装态”的区别是：“阻塞装态”在等待着获取到一个排他锁，这个时间将在另外一个线程放弃这个锁的时候发生；而“等待装态”则是在等待一段时间，或者唤醒动作的发生。在程序等待进入同步区域的时候，线程进入这种装态。
  * **结束（Terminated）：** 已结束线程的线程状态，线程已经结束执行。
    
    
    
    
    
    

