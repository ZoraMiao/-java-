# 垃圾收集(GC)
## 判断对象是否存活
**引用计数算法**  <br>
  给对象添加一个引用计数器，每当有一个地方引用他时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用，将对其回收。<br>
  但是主流的java虚拟机里面没有选用这种方法来管理内存，主要因为它很难解决对象之间相互循环引用的问题。例如：<br>
  ```java
  public class MyObject {
    public Object ref = null;
    public static void main(String[] args) {
        MyObject myObject1 = new MyObject();
        MyObject myObject2 = new MyObject();
        myObject1.ref = myObject2;
        myObject2.ref = myObject1;
        myObject1 = null;
        myObject2 = null;
    }
  }
  ```
  这两个对象没有任何其他的引用，但是他们之间相互引用着对方，导致它们的计数器都不为0，于是引用计数法无法通知GC收集器回收它们。<br>
**可达性分析算法**<br>
  通过一系列的称为"GC Roots"的对象作为起点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用；是可回收对象。<br>
  在java语言中，可作为GC Roots的对象包括下面几种：<br>
  * 虚拟机栈（栈帧中的本地变量表）中引用的对象
  * 方法区中类静态属性引用的对象
  * 方法区中常量引用的对象
  * 本地方法栈中JNI（即一般说的Native方法）引用的对象
## 垃圾回收算法
### 标记-清除算法
  标记清除法是现代垃圾回收算法的思想基础。<br>
  标记清除法将垃圾回收分为两个阶段：**标记阶段**和**清除阶段**。<br>
  在标记阶段，使用**可达性分析算法**，首先通过根节点，标记所有从根节点开始的可达对象，因此未被标记的对象就是未被引用的垃圾对象。然后在清除阶段，清除所有未被标记的对象。这种方法可以解决循环引用的问题，只有两个对象不可达，即使它们互相引用也无济于事。也是会被判定位不可达对象。<br>
  标记清除算法可能产生的最大的问题就是**空间碎片**。空间碎片太多会导致当程序需要为较大对象分配内存时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。<br>
  如下图所示，简单描述了使用标记清除法对一块连续的内存空间进行回收。<br>
![](https://images2015.cnblogs.com/blog/989246/201704/989246-20170406161514082-1220415753.jpg)<br>
  从上图可以看出，回收后的内存空间不再连续。在对象的对空间分配过程中，尤其是大对象的内存分配，不连续内存空间的工作效率要低于连续空间的，这也是该算法的缺点。**注意：标记清除算法先通过根节点标记所有可达对象，然后清除所有不可达对象，完成垃圾回收。后面会讲到标记压缩算法，注意两者的区别。**
### 复制算法
  算法思想：将原有的内存空间分为两块相同的存储空间，每次只使用一块，在垃圾回收时，将正在使用的内存块中存活对象复制到未使用的那一块内存空间中，之后清除正在使用的内存块中的所有对象，完成垃圾回收。<br>
  如果系统中的垃圾对象很多，复制算法需要复制的存活对象就会相对较少**（适用场景）**。因此，在真正需要垃圾回收的时刻，复制算法的效率是很高的。而且，由于存活对象在垃圾回收过程中是一起被赋值到另一块内存空间中的，因此，可确保回收的内存空间是没有碎片的。**（优点）**<br>
  但是复制算法的代价是将系统内存空间折半，只使用一半空间，而且如果内存空间中垃圾对象少的话，复制对象也是很耗时的，因此，单纯的复制算法也是不可取的。**（缺点）**<br>
  ![](https://images2015.cnblogs.com/blog/989246/201704/989246-20170406162053957-592638524.jpg)
### 标记-整理算法
[相关文章](https://blog.csdn.net/wen7280/article/details/54428387)
