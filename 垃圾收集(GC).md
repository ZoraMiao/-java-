# 垃圾收集(GC)
## 1、判断对象是否存活
**引用计数算法**  <br>
  给对象添加一个引用计数器，每当有一个地方引用他时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用，将对其回收。<br>
  但是主流的java虚拟机里面没有选用这种方法来管理内存，主要因为它很难解决对象之间相互循环引用的问题。例如：<br>
  ```java
  public class MyObject {
    public Object ref = null;
    public static void main(String[] args) {
        MyObject myObject1 = new MyObject();
        MyObject myObject2 = new MyObject();
        myObject1.ref = myObject2;
        myObject2.ref = myObject1;
        myObject1 = null;
        myObject2 = null;
    }
  }
  ```
  这两个对象没有任何其他的引用，但是他们之间相互引用着对方，导致它们的计数器都不为0，于是引用计数法无法通知GC收集器回收它们。<br>
**可达性分析算法**<br>
  通过一系列的称为"GC Roots"的对象作为起点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用；是可回收对象。<br>
  在java语言中，可作为GC Roots的对象包括下面几种：<br>
  * 虚拟机栈（栈帧中的本地变量表）中引用的对象
  * 方法区中类静态属性引用的对象
  * 方法区中常量引用的对象
  * 本地方法栈中JNI（即一般说的Native方法）引用的对象
## 2、垃圾回收算法
### 标记-清除算法
  标记清除法是现代垃圾回收算法的思想基础。<br>
  标记清除法将垃圾回收分为两个阶段：**标记阶段**和**清除阶段**。<br>
  在标记阶段，使用**可达性分析算法**，首先通过根节点，标记所有从根节点开始的可达对象，因此未被标记的对象就是未被引用的垃圾对象。然后在清除阶段，清除所有未被标记的对象。这种方法可以解决循环引用的问题，只有两个对象不可达，即使它们互相引用也无济于事。也是会被判定位不可达对象。<br>
  标记清除算法可能产生的最大的问题就是**空间碎片**。空间碎片太多会导致当程序需要为较大对象分配内存时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。<br>
  如下图所示，简单描述了使用标记清除法对一块连续的内存空间进行回收。<br>
![](https://images2015.cnblogs.com/blog/989246/201704/989246-20170406161514082-1220415753.jpg)<br>
  从上图可以看出，回收后的内存空间不再连续。在对象的对空间分配过程中，尤其是大对象的内存分配，不连续内存空间的工作效率要低于连续空间的，这也是该算法的缺点。**注意：标记清除算法先通过根节点标记所有可达对象，然后清除所有不可达对象，完成垃圾回收。后面会讲到标记压缩算法，注意两者的区别。**
### 复制算法
  算法思想：将原有的内存空间分为两块相同的存储空间，每次只使用一块，在垃圾回收时，将正在使用的内存块中存活对象复制到未使用的那一块内存空间中，之后清除正在使用的内存块中的所有对象，完成垃圾回收。<br>
  如果系统中的垃圾对象很多，复制算法需要复制的存活对象就会相对较少 **（适用场景）** 。因此，在真正需要垃圾回收的时刻，复制算法的效率是很高的。而且，由于存活对象在垃圾回收过程中是一起被赋值到另一块内存空间中的，因此，可确保回收的内存空间是没有碎片的。 **（优点）**<br>
  但是复制算法的代价是将系统内存空间折半，只使用一半空间，而且如果内存空间中垃圾对象少的话，复制对象也是很耗时的，因此，单纯的复制算法也是不可取的。 **（缺点）**<br>
  ![](https://images2015.cnblogs.com/blog/989246/201704/989246-20170406162053957-592638524.jpg)
### 标记-整理算法
  复制算法的高效性是建立在存活对象少、垃圾对象多的情况下，这种情况在新生代比较常见，但是在老年代中，大部分对象都是存活的对象，如果还是有复制算法的话，成本会比较高。因此，基于老年代这种特性，应该使用其他的回收算法。<br>
  标记压缩算法是老年代的回收算法，它在标记清除算法的基础上做了优化。（回忆一下，标记清除算法的缺点，垃圾回收后内存空间不再连续，影响了内存空间的使用效率。。。）,和标记清除算法一样，标记压缩算法也首先从根节点开始，对所有可达的对象做一次标记，但之后，它并不是简单的清理未标记的对象，而是将所有的存活对象压缩到内存空间的一端，之后，清理边界外所有的空间。这样做**避免了碎片的产生**，又不需要两块相同的内存空间，因此性价比高。
通过根节点标记出所有的可达对象后，进行对象的移动，将所有的可达对象移到一端，并保持他们之间的引用关系，最后，清理边界外的空间。<br>
![](https://images2015.cnblogs.com/blog/989246/201704/989246-20170406162848519-1635773526.jpg)
### 分代收集算法
  当前商业虚拟机的垃圾收集都采用“分代收集”(Generational Collection)算法，这种算法并没有什么新的思想，只是根据对象存活周期的不同将内存划分为几块。一般是把 Java堆分为**新生代**和**老年代**，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记一-清理”或者“标记一整理”算法来进行回收。<br>
[相关文章](https://blog.csdn.net/wen7280/article/details/54428387)
## 3、典型的垃圾回收算法
  垃圾收集算法是垃圾收集器的理论基础，而垃圾收集器就是其具体实现。下面介绍HotSpot虚拟机提供的几种垃圾收集器。<br>
  ![](https://img-blog.csdn.net/20170102225015393)
### 3.1. Serial/Serial Old
  最古老的收集器，是一个单线程收集器，用它进行垃圾回收时，必须暂停所有用户线程。Serial是针对新生代的收集器，采用Copying算法；而Serial Old是针对老生代的收集器，采用Mark-Compact算法。优点是简单高效，缺点是需要暂停用户线程。
### 3.2. ParNew
  Seral/Serial Old的多线程版本，使用多个线程进行垃圾收集。
### 3.3. Parallel Scavenge
  新生代的并行收集器，回收期间不需要暂停其他线程，采用Copying算法。该收集器与前两个收集器不同，主要为了达到一个可控的吞吐量。
### 3.4. Parallel Old
  Parallel Scavenge的老生代版本，采用Mark-Compact算法和多线程。
### 3.5. CMS
  Current Mark Sweep收集器是一种以最小回收时间停顿为目标的并发回收器，因而采用Mark-Sweep算法。
### 3.6. G1
  G1(Garbage First)收集器技术的前沿成果，是面向服务端的收集器，能充分利用CPU和多核环境。是一款并行与并发收集器，它能够建立可预测的停顿时间模型。
### 相关文章
  [垃圾收集器](https://blog.csdn.net/tjiyu/article/details/53983650)
