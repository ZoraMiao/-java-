# 垃圾收集(GC)
## 判断对象是否存活
**引用计数算法**  <br>
  给对象添加一个引用计数器，每当有一个地方引用他时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用，将对其回收。<br>
  但是主流的java虚拟机里面没有选用这种方法来管理内存，主要因为它很难解决对象之间相互循环引用的问题。例如：<br>
  ```java
  public class MyObject {
    public Object ref = null;
    public static void main(String[] args) {
        MyObject myObject1 = new MyObject();
        MyObject myObject2 = new MyObject();
        myObject1.ref = myObject2;
        myObject2.ref = myObject1;
        myObject1 = null;
        myObject2 = null;
    }
  }
  ```
  这两个对象没有任何其他的引用，但是他们之间相互引用着对方，导致它们的计数器都不为0，于是引用计数法无法通知GC收集器回收它们。<br>
**可达性分析算法**<br>
  通过一系列的称为"GC Roots"的对象作为起点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用；是可回收对象。<br>
  在java语言中，可作为GC Roots的对象包括下面几种：<br>
  * 虚拟机栈（栈帧中的本地变量表）中引用的对象
  * 方法区中类静态属性引用的对象
  * 方法区中常量引用的对象
  * 本地方法栈中JNI（即一般说的Native方法）引用的对象
## 垃圾回收算法
### 标记-清除算法
  
### 复制算法
### 标记-整理算法
  标记清除法是现代垃圾回收算法的思想基础。<br>
  标记清除法将垃圾回收分为两个阶段：**标记阶段**和**清除阶段**。<br>
  在标记阶段，使用**可达性分析算法**，首先通过根节点，标记所有从根节点开始的可达对象，因此未被标记的对象就是未被引用的垃圾对象。然后在清除阶段，清除所有未被标记的对象。这种方法可以解决循环引用的问题，只有两个对象不可达，即使它们互相引用也无济于事。也是会被判定位不可达对象。<br>
  标记清除算法可能产生的最大的问题就是空间碎片。空间碎片太多会导致当程序需要为较大对象分配内存时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。<br>
  如下图所示，简单描述了使用标记清除法对一块连续的内存空间进行回收。<br>
  从根节点开始（在这里仅显示了两个根节点），所有的有引用关系的对象均被标记为存活对象（箭头表示引用）。从根节点起，不可达对象均为垃圾对象。在标记操作完成后，系统回收所有不可达对象。<br>
  ![](https://img-blog.csdn.net/20170114203544552?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2VuNzI4MA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)<br>
  从上图可以看出，回收后的内存空间不再连续。在对象的对空间分配过程中，尤其是大对象的内存分配，不连续内存空间的工作效率要低于连续空间的，这也是该算法的缺点。**注意：标记清除算法先通过根节点标记所有可达对象，然后清除所有不可达对象，完成垃圾回收。后面会讲到标记压缩算法，注意两者的区别。**
