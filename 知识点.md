# 匿名内部类
  匿名内部类的创建格式为： new 父类构造器（参数列表）|实现接口（）{  //匿名内部类的类体实现 }<br>
  >使用匿名内部类时，必须继承一个类或实现一个接口<br>
  匿名内部类由于没有名字，因此不能定义构造函数<br>
  匿名内部类中不能含有静态成员变量和静态方法<br>
# Vector & ArrayList 的主要区别 
>1） 同步性:Vector是线程安全的，也就是说是同步的 ，而ArrayList 是线程序不安全的，不是同步的 数组。 <br>
2）数据增长:当需要增长时,Vector默认增长为原来一倍 ，而ArrayList却是原来的50%  ，这样,ArrayList就有利于节约内存空间。<br>
      如果涉及到堆栈，队列等操作，应该考虑用Vector，如果需要快速随机访问元素，应该使用ArrayList 。<br>

## 扩展知识：
### 1. Hashtable & HashMap 
>Hashtable和HashMap它们的性能方面的比较类似 Vector和ArrayList，比如Hashtable的方法是同步的,而HashMap的不是。
## 2. ArrayList & LinkedList

ArrayList的内部实现是基于内部数组Object[],所以从概念上讲,它更象数组，但LinkedList的内部实现是基于一组连接的记录，所以，它更象一个链表结构，所以，它们在性能上有很大的差别：   <br>
       从上面的分析可知,在ArrayList的前面或中间插入数据时,你必须将其后的所有数据相应的后移,这样必然要花费较多时间，所以,当你的操作是在一列数据的后面添加数据而不是在前面或中间,并且需要随机地访问其中的元素时,使用ArrayList会提供比较好的性能； 而访问链表中的某个元素时,就必须从链表的一端开始沿着连接方向一个一个元素地去查找,直到找到所需的元素为止，所以,当你的操作是在一列数据的前面或中间添加或删除数据，并且按照顺序访问其中的元素时，就应该使用LinkedList了。
# 类之间存在以下几种常见的关系：
>use-a 是依赖关系<br>
has-a   一般是组合关系<br>
is-a   一般是继承关系
# final
>final修饰类、方法、属性！不能修饰抽象类，因为抽象类一般都是需要被继承的，final修饰后就不能继承了。<br>
>final修饰的方法不能被重写而不是重载！ <br>
>final修饰属性，此属性就是一个常量，不能被再次赋值！ 
# 管道特点
>1.管道只允许具有血缘关系的进程间通信，如父子进程间的通信。<br>
2.管道只允许单向通信。<br>
3.管道内部保证同步机制，从而保证访问数据的一致性。<br>
4.面向字节流<br>
5.管道随进程，进程在管道在，进程消失管道对应的端口也关闭，两个进程都消失管道也消失。
# java中各个代码块的区别
  [相关文章](https://www.cnblogs.com/ysocean/p/8194428.html#_label3)
# 线程中各方法的用途
* join(): 调用线程，等待线程运行完成（可使主线程等待子线程先执行）
* sleep(): 暂停一会，不释放对象锁（如synchronized）在没有同步锁时，可以使低优先级的线程有机会运行
* wait()（**必须在synchronized中使用**）:使当前线程暂停执行，并释放对象锁，当前线程被放入对象池中，其他线程才可进入synchronized中
* notify(): 将从对象的等待池中移走一个任意的线程并放到锁标志等待池中，只有锁标志等待池中线程能够获取锁标志，如果锁标志等待池中没有线程，则notify()不起作用
* notifyAll(): 从对象等待池中移走所有等待那个对象的线程并放到锁标志等待池中
* yield(): 将目前正在执行的线程暂停，允许其他线程执行，只能让同优先级别的线程有执行机会
* start(): 启动线程，自动调用run()方法
* run(): 线程中具体的执行代码放在此方法中
# 正则表达式符号的用途
[相关文章]（https://wenku.baidu.com/view/11a55217f18583d04964599d.html）
