## 线程安全
> 当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象是线程安全的。
* java语言中各种操作共享的数据分为以下5类：**不可变、绝对线程安全、相对线程安全、线程兼容和线程对立。**
  * **不可变：** 不可变（Immutable）的对象一定是线程安全的，无论是对象的方法实现还是方法的调用者，都不需要再采取任何的线程安全保障措施。（例如final，只要一个不可变的对象被正确地构建出来（没有发生this引用逃逸的情况），那其外部的可见壮、状态永远也不会改变，永远也不会看到它在多个线程之中处于不一致的装态。）
 > java语言中，如果共享数据是一个基本数据类型，那么只要在定义时使用final关键字修饰它就可以保证它是不可变的。如果共享数据是一个对象，那就需要保证对象的行为对其状态产生任何影响才行。例如java.lang.String类的对象，它是一个典型的不可变对象，我们调用它的substring()、replace()和concat()这些方法都不会影响它原来的值，只会返回一个新构造的字符串对象。
  * **绝对线程安全：**一个类要达到“不管运行时环境如何，调用者都不需要任何额外的同步措施”。在java API中标注自己是线程安全的类，大多数都不是绝对的线程安全。例如java.lang.Vector是一个线程安全的容器，因为它的add()、get()和size()这类方法都是被synchronized修饰的，尽管这样效率很低，但确实是安全的。但是，即使它所有的方法都被修饰成同步的，也不意味着调用它的时候永远不再需要同步手段。
  * **相对线程安全：** 就是我们通常意义上所讲的线程安全，它需要保证对这个对象单独的操作时线程安全的，我们在调用的时候不需要做额外的保障措施。但是对于一些特定顺序的连续调用，就可能需要在调用端使用额外的同步手段来保证调用的正确性。像java.lang.Vector就是相对线程安全的。
  * **线程兼容：** 是指队形本身并不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全地使用。java API中大部分的类都是属于线程兼容的，如与前面的Vector和HashTable相对应的集合类ArrayList和HashMap等。
  * **线程对立：** 是指无论调用端是否采取了同步措施，都无法在多线程环境中并发使用的代码。由于java语言天生就具备多线程特性，线程对立排斥多线程的代码是很少出现的，而且通常都是有害的，应当尽量避免。例如Thread类的suspend()和resume()方法，如果两个线程同时持有一个线程对象，一个尝试去中断线程，另一个尝试去恢复线程，如果并发进行的话，无论调用时是否进行了同步，目标线程都是存在死锁风险的。
## 线程安全的实现方法
  * **1、互斥同步（悲观）
    * 是指在多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一个（或一些，使用信号量的时候）线程使用。**临界区**、**互斥量**、**信号量** 都是主要的互斥实现方式。
    * 在java中，最基本的互斥手段就是synchronized关键字
  * **2、非阻塞同步（乐观）
  * **3、无同步方案
