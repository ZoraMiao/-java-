# 类文件结构
## Class 类文件的结构
  Class文件是一组以8位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在Class文件之中，中间没有添加任何分隔符，这使得整个Class文件中存储的内容几乎全部是程序运行的必要数据，没有空隙存在。当遇到需要占用8位字节以上的数据项时，则会按照高位在前的方式分割成若干个8位字节进行存储。<br>
  根据java虚拟机规范的规定Class文件格式采用一种类似于C语言结构体的伪结构来存储数据，这种伪结构中只有两种数据类型：**无符号**和**表**。<br>
  **无符号数**属于基本的数据类型，以u1、u2、u4、u8来分别代表1个字节、2个字节、4个字节、8个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值。<br>
  **表**是由多个无符号或者其他表作为数据项构成的符合数据类型，所有表都习惯性地以“_info”结尾。表用于描述有层次关系的复合结构的数据，整个Class文件本质上就是一个表，它是由如下所示的数据项构成：<br>
![](https://github.com/ZoraMiao/java/blob/master/class文件格式.png)<br>
  无论是无符号数还是表，当需要描述同一类型但数量不定的多个数据时，经常会使用一个**前置的容量计数器**加**若干个连续的数据项**的形式，这是称这一系列的某一类型的数据为某一类型的集合。<br>
### 魔数与class文件的版本
  每个class文件的头4个字节称为魔数(Magic Number)，其值为：0xCAFEBABE，它的唯一作用是用于确定这个文件是否为一个能被虚拟机接受的class文件。使用魔数而不是扩展名来进行识别主要是基于安全的考虑，因为文件的扩展名可以随意地被改动。<br>
  紧接着魔数的4个字节存储的是class文件的版本号：第5和第6个字节是次版本号(Minor Version)，第7和第8个字节是主版本号(Major Version)。java的版本是从45开始的，JDK1.1之后的每个JDK大版本发布主版本号上加1(JDK1.0-1.1使用了45.0-45.3的版本号)，高版本的JDK能向下兼容以前版本的class文件，但不能运行以后版本的class文件，即使文件格式并未发生变化。JDK1.2对应主版本号为46，JDK1.3为47，依此类推。
  ### 相关文章
  [www.mamicode.com/info-detail-2164149.html](www.mamicode.com/info-detail-2164149.html)
### 常量池
  由于常量池中常量的数据是不固定的，所以在常量池的入口需要放置一荐u2类型的数据，代表常量池容量计算值(constant_pool_count)。与Java语言习惯不一样的是，这个容量计数是从1而不是0开始的。将第0项常量出来的目的是为了满足后面某些指向常量池的索引值的数据在特定情况下需要表达“不引用任何一个常量池项目”的意思。class文件结构中只有常量池的容量计数是从1开始，对于其它集合类型，包括接口索引集合，字段表集合，方法表集合的容量计算都是从0开始的。<br>
   常量池中主要存放两大类常量：字面量(Literal)和符号引用(Symbolic References)。字面量比较接近于Java语言层面的常量概念，如文本字符串，被声明为final的常量值等。而符号引用则属性编译原理方面的概念，包含了下面三类常量：<br>
  >a.类和接口的全限定名(Fully Qualified Name)<br>
  b.字段的名称和描述符(Descriptor)<br>
  c.方法的名称和描述符<br>
  
  常量池中每一项常量都是一个表，在JDK1.7之前共有11种结构各不相同的表结构数据，在JDK1.7中为了更好地支持动态语言调用，又额外增加了3种（CONSTANT_MethodHandle_info,CONSTANT_MethodType_info和CONSTANT_InvokeDynamic_info）。这14种表都有一个共同的特点，就是表开始的第一位是一个u1类型的标志位（tag），代表当前这个常量属于那种常量类型。<br>
  ![](https://github.com/ZoraMiao/java/blob/master/常量池的项目类型.png)<br>
  各常量项结构：<br>
  ![](https://github.com/ZoraMiao/java/blob/master/常量项结构_1.png)<br>
  ![](https://github.com/ZoraMiao/java/blob/master/常量项结构_2.png)<br>
  由于Class文件中方法、字段等都需要引用CONSTANT_Utf8_info型常量来描述名称，所以**CONSTANT_Utf8_info型常量的最大长度也就是java中方法、字段名的最大长度**。而这里的最大长度就是length的最大长度，既u2类型能表达的最大值65535。所以java程序中如果定义了超过64KB英文字符的变量或方法名，将会无法编译。
### 访问标志
  在常量池结束之后，紧接着的两个字节代表访问标志（access_flags）,这个标志用于识别一些类或者接口层次的访问信息，包括这个class是类还是接口：是否定义为public类型；是否定义为abstract类型；如果是类的话，是否被声明为final等。<br>
  ![](https://github.com/ZoraMiao/java/blob/master/访问标志.png)<br>
### 类索引、父类索引与接口索引集合
  类索引 (this_class)和父类索引(super_class)都是一个 u2类型的数据，而接口索引集合(interfaces) 是一组u2类型的数据的集合，Class 文件中由这三项数据来确定这个类的继承关系。类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名。由于Java语言不允许多重继承，所以父类索引只有一个，除了java.lang.Object之外，所有的Java类都有父类，因此除了java.lang.Object外，所有Java类的父类索引都不为0。接口索引集合就用来描述这个类实现了哪些接口，这些被实现的接口将按implements语句(如果这个类本身是一个接口，则应当是extends语句)后的接口顺序从左到右排列在接口索引集合中。<br>
  类索引、父类索引和接口索引集合都按顺序排列在访问标志之后，类索引和父类索引用两个u2类型的索引值表示，它们各自指向一个类型为CONSTANT_Class_info的类描述符常量，通过CONSTANT_Class_info 类型的常量中的索引值可以找到定义在CONSTANT_Ut8_info类型的常量中的全限定名字符串。<br>
  对于接口索引集合，入口的第一项一u2 类型的数据为接口计数器(interfaces_count)，表示索引表的容量。如果该类没有实现任何接口，则该计数器值为0，后面接口的索引表不再占用任何字节。<br>
  ![](https://github.com/ZoraMiao/java/blob/master/类+父类+接口索引(集合).png)<br>
  ### 相关文章
  [https://blog.csdn.net/luanlouis/article/details/41039269](https://blog.csdn.net/luanlouis/article/details/41039269)
### 字段表集合
  字段表(field_info)用于描述接口或者类中声明的变量。字段(field) 包括类级变量以及实例级变量，但不包括在方法内部声明的局部变量。我们可以想一想在Java中描述一个字段可以包含什么信息?可以包括的信息有:字段的作用域(public、private、 protected 修饰符)、是实例变量还是类变量(static 修饰符)、可变性(final)、 并发可见性(volatile 修饰符，是否强制从主内存读写)、可否被序列化(transient 修饰符)、字段数据类型(基本类型、对象、数组)、字段名称。上述这些信息中，各个修饰符都是布尔值，要么有某个修饰符，要么没有，很适合使用标志位来表示。而字段叫什么名字、字段被定义为什么数据类型，这些都是无法固定的，只能引用常 量池中的常量来描述。<br>
  | 类型           | 名称             | 数量              |
  | :------------  | :--------------- | :-------------- |
  | u2             | access_flags     | 1                |
  | u2             | name_index       | 1                |
  | u2             | descriptor_index | 1                |
  | u2             | attributes_count | 1                |
  | attribute_info | attributes       | attributes_count |
